<?xml version="1.0" encoding="UTF-8"?>
<db xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:schemaLocation="http://www.unioverflow.com db.xsd">
  <users>
    <user>
      <email>enrico.rotundo@studenti.unipd.it</email>
      <password>12345678</password>
    </user>
    <user>
      <email>giacomo.fornari@studenti.unipd.it</email>
      <password>12345678</password>
    </user>
    <user>
      <email>federico.poli.1@studenti.unipd.it</email>
      <password>federico</password>
    </user>
    <user>
      <email>serena.girardi@studenti.unipd.it</email>
      <password>qwertyuiop</password>
    </user>
  </users>
  <questions>
<question id="2"><title>[C] Calcolo percorso breve</title><content>Ciao ragazzi, sto cercando di risolvere un esercizio:&#13;
&#13;
"Dati un vertice sorgente, uno destinazione e una tipologia di distanze (d1 oppure d2 oppure&#13;
d3) inseriti dall’utente, calcola il percorso più breve tra sorgente e destinazione, mostrando a&#13;
monitor tale percorso e la relativa distanza."&#13;
&#13;
Essendo che la struttura dati in questione è un grafo orientato e che d1 d2 e d3 sono i pesi del grafo (numeri reali tipo 1.2, 3.4, 5.6 etc, tutti positivi) pensavo di utilizzare l'algoritmo di Dijkstra, è la soluzione migliore per il mio caso? Ho a disposizione lo pseudocodice da alcune dispense, ma ho bisogno di aiuto per implementarlo in C. &#13;
&#13;
Ci sono due cose che non mi sono chiare:&#13;
1) questa riga nella funzione 'inizializza':&#13;
vertice_p-&gt;distanza_min = INFINITO;&#13;
come implemento questo INFINITO?&#13;
2) /costruisci un insieme per i vertici già considerati (inizialmente vuoto) .;&#13;
/costruisci una struttura per i vertici da considerare (inizialmente tutti) .;&#13;
non sono sicuro di aver capito come svolgere questa parte.&#13;
&#13;
*void dijkstra(vertice grafo t *grafo p,&#13;
                               vertice grafo t *sorgente p)&#13;
{&#13;
     vertice grafo t *vertice p;&#13;
     arco grafo t *arco p;&#13;
&#13;
     inizializza(grafo p,&#13;
                      sorgente p);&#13;
&#13;
     /costruisci un insieme per i vertici già considerati (inizialmente vuoto) .;&#13;
     /costruisci una struttura per i vertici da considerare (inizialmente tutti) .;&#13;
&#13;
     while (/la struttura non è vuota .)&#13;
     {&#13;
               /rimuovi dalla struttura il vertice vertice p con distanza min minima .;&#13;
               /inserisci vertice p nell’insieme dei vertici già considerati .;&#13;
&#13;
                for (arco p = vertice p-&gt;lista archi p;&#13;
                        (arco p != NULL);&#13;
                       arco p = arco p-&gt;arco succ p)&#13;
                     if (arco p-&gt;vertice adiac p non è nell’insieme dei vertici già considerati .)&#13;
                             riduci(arco p,&#13;
                                         vertice p);&#13;
      }&#13;
}*</content><author>giacomo.fornari@studenti.unipd.it</author><insertDate>2014-05-12</insertDate><status>opened</status></question><question id="3"><title>Linguaggio C, dividere una stringa in più stringhe</title><content>**Testo:**&#13;
&#13;
Definire il tipo di dato record Automobile, contenente i seguenti campi:&#13;
- marca, di tipo stringa (max 20 caratteri)&#13;
- modello, di tipo stringa (max 20 caratteri)&#13;
- prezzo, di tipo intero&#13;
&#13;
Implementare la funzione C: void leggi_automobili(char* nomefile, Automobile parco[10], int *n) che, presi in input una stringa contenente il percorso di un file, un array di Automobile di dimensione 10 ed un puntatore ad intero n, inserisce nell’array, partendo dalla componente 0, tutte le automobili rappresentate nel file, seguendo lo stesso ordine dell’array, ed assegna alla variabile puntata da n il numero di componenti significative dell’array (ovvero quante automobili vi sono state inserite). &#13;
Il formato del file è il seguente:&#13;
- la prima riga del file contiene il numero di automobili contenute nel file&#13;
- ciascuna delle successive righe contiene, nell’ordine specificato, la marca, il modello ed il prezzo dell’automobile.&#13;
Assumere che il file non contenga mai più di 10 automobili.&#13;
&#13;
**File TXT**&#13;
*5&#13;
fiat panda 9000&#13;
lancia y 12500&#13;
volkswagen golf 15000&#13;
fiat punto 11000&#13;
audi quattro 60000*</content><author>federico.poli.1@studenti.unipd.it</author><insertDate>2014-05-15</insertDate><status>opened</status></question><question id="4"><title>elimare elemento di una lista</title><content>ragazzi scusate è possibile implementare una funzione void che elimini un elemento da una lista doppiamente puntata?</content><author>federico.poli.1@studenti.unipd.it</author><insertDate>2014-05-30</insertDate><status>opened</status></question><question id="1"><title>PROBLEMA COMPILAZIONE FILE C++ SU UBUNTU</title><content>Salv a tutti, sono uno studente di informatica e sto eseguendo un progetto riguardo la realizazzione di un GPS. &#13;
Qaundo vado a compilare il file main.cpp spunta questo errore: In file included from main.cpp:14:0:&#13;
TA.h:24:2: error: expected class-name before ‘{’ token&#13;
&#13;
Qualcuno di voi sa cosa possa essere? Se volete vi posso anche inviare il codice.</content><author>federico.poli.1@studenti.unipd.it</author><insertDate>2014-05-15</insertDate><status>solved</status></question><question id="5"><title>[C++]Memorizzare file in memoria.</title><content>Salve a tutti, devo memorizzare il contenuto di un file in memoria, dato che nel corso del mio programma dovrò accedervi molte volte e scrorrerlo un po' in tutti i modi, inoltre ha un numero limitato di righe, ecco un esempio:&#13;
&#13;
ID NOME COGNOME NUMERO&#13;
1 Andrea Bianchi 544234234&#13;
2 Marco Rossi 423435324&#13;
.&#13;
.&#13;
.&#13;
10&#13;
&#13;
Per memorizzarlo ho fatto nel seguente modo:&#13;
*ifstream mazzoPrincipale&#13;
string contentPrinc [10][4]&#13;
int i=0;&#13;
&#13;
  while(!(mazzoPrincipale.eof()))&#13;
   {&#13;
    mazzoPrincipale&gt;&gt;contentPrinc[i][0]&gt;&gt;contentPrinc[i][1]&gt;&gt;contentPrinc[i][2]&gt;&gt;contentPrinc[i][3]&#13;
        i++;&#13;
   }*</content><author>federico.poli.1@studenti.unipd.it</author><insertDate>2014-05-17</insertDate><status>opened</status></question><question id="6"><title>Esercizio esame imminente</title><content>Ciao a tutti ragazzi, ho un problema con questo semplice programma. Praticamente non mi stampa la lista aggiornata una volta che faccio l'inserimento in coda. Grazie a tutti!&#13;
P.s. vi allego programma e output&#13;
&#13;
/* Programma per la costruzione e l'inserimento in coda di un elemento in una stringa */&#13;
&#13;
*#include &lt;stdio.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
#include &lt;string.h&gt;&#13;
&#13;
typedef char tipoelem;&#13;
&#13;
struct strutturalista {&#13;
   tipoelem info;&#13;
   struct strutturalista *next;&#13;
};&#13;
&#13;
typedef struct strutturalista tiponodo;&#13;
&#13;
typedef tiponodo *tipolista; &#13;
&#13;
tipolista costruiscilista() {&#13;
tipolista list = NULL;&#13;
tiponodo *ultimo, *pgen;&#13;
tipoelem dato;&#13;
   &#13;
   pgen=malloc(sizeof(tiponodo));&#13;
   if(pgen==NULL) {&#13;
   printf("Errore in allocazione del RG\n");&#13;
   return NULL;&#13;
   }&#13;
      ultimo=pgen;&#13;
      printf("Scrivi i caratteri per comporre la lista:\n");&#13;
      scanf("%c",&amp;dato);&#13;
      &#13;
         while(dato!='0') {&#13;
         ultimo-&gt;next=malloc(sizeof(tiponodo));&#13;
         ultimo=ultimo-&gt;next;&#13;
         ultimo-&gt;info=dato;&#13;
         scanf("%c",&amp;dato);&#13;
         }&#13;
            ultimo-&gt;next=NULL;&#13;
             list=pgen-&gt;next;&#13;
            free(pgen);&#13;
            return list;&#13;
}&#13;
&#13;
void stampalista (tipolista list) {&#13;
tiponodo *aux;&#13;
&#13;
aux=list;&#13;
while(aux-&gt;next!=NULL) {&#13;
   printf("%c",aux-&gt;info);&#13;
   aux=aux-&gt;next;&#13;
    }&#13;
}&#13;
&#13;
void insincoda (tipolista *plis, tipoelem el) {&#13;
tiponodo *aux, *ultimo, *pgen;&#13;
&#13;
   pgen=malloc(sizeof(tiponodo));&#13;
   if(pgen==NULL) {&#13;
   printf("Errore in allocazione del RG\n");&#13;
   return;&#13;
   }&#13;
      pgen-&gt;next=*plis;&#13;
      aux=pgen;&#13;
         while(aux-&gt;next)&#13;
         aux=aux-&gt;next;&#13;
      ultimo=aux;&#13;
            ultimo-&gt;next=malloc(sizeof(tiponodo));&#13;
            ultimo-&gt;next-&gt;info=el;&#13;
            ultimo-&gt;next-&gt;next=NULL;&#13;
            *plis=pgen-&gt;next;&#13;
            free(pgen);&#13;
            return;&#13;
}&#13;
&#13;
int main() {&#13;
   tipolista lista;&#13;
   tipoelem elem;&#13;
         &#13;
printf("Costruzione della lista\n");&#13;
printf("Inserisci 0 per terminare l'inserimento...\n\n");&#13;
lista = costruiscilista();&#13;
printf("\n");&#13;
printf("Inserisci l'elemento che va in coda -&gt; ");&#13;
scanf(" %c", &amp;elem);&#13;
insincoda(&amp;lista, elem);&#13;
stampalista(lista);&#13;
return 0;&#13;
}* </content><author>serena.girardi@studenti.unipd.it</author><insertDate>2014-05-17</insertDate><status>opened</status></question><question id="7"><title>Linguaggio C
++</title><content>Ciao, vorrei sapere come si può associare un programma C++ ad una interfaccia grafica. Vorrei rendere gradevoli i miei programmini al posto di vederli sempre sul dos! 
Che programma si usa? Ho appena scaricato Visual C++...</content><author>federico.poli.1@studenti.unipd.it</author><insertDate>2014-05-17</insertDate><status>opened</status></question><question id="8"><title>Linguaggio C, ritornare puntatore alla componente dell'array</title><content>Implementare float* minimo(const float* array, int size)&#13;
&#13;
che, presi in input un array di float e la sua dimensione size, restituisce il puntatore alla componente dell’array contenente il valore minimo. </content><author>federico.poli.1@studenti.unipd.it</author><insertDate>2014-05-17</insertDate><status>opened</status></question></questions>
  <answers>
    <answer id="1">
      <content>Perl è un linguaggio di programmazione ad alto livello, dinamico, procedurale e interpretato, creato nel 1987 da Larry Wall. Perl ha un singolare insieme di funzionalità ereditate da C, scripting shell Unix (sh), Awk, sed e in diversa misura da molti altri linguaggi di programmazione, compresi alcuni linguaggi funzionali.</content>
      <author>giacomo.fornari@studenti.unipd.it</author>
      <question>1</question>
      <insertDate>2014-04-27</insertDate>
    </answer>
  <answer id="2"><content>Questa è una *risposta* con tanta ma **tanta** formattazione. E ci sono anche
tanti
tanti
a-capo.
Si vedono bene?</content>
      <author>federico.poli.1@studenti.unipd.it</author>
      <question>1</question>
      <insertDate>2014-04-29</insertDate>
    </answer>
  <answer id="3"><content>Funziona tutto no?&#13;
*Serena*</content><author>serena.girardi@studenti.unipd.it</author><question>2</question><insertDate>2014-05-18</insertDate></answer><answer id="4"><content>Mostra l'include</content><author>federico.poli.1@studenti.unipd.it</author><question>3</question><insertDate>2014-05-30</insertDate></answer><answer id="5"><content>*#include &lt;unistd.h&gt;&#13;
#include &lt;pthread.h&gt;&#13;
#include &lt;stdlib.h&gt;&#13;
#include &lt;stdio.h&gt;&#13;
#include &lt;string.h&gt;&#13;
#include &lt;math.h&gt;&#13;
&#13;
//#include "GPS.h"&#13;
#include "TA.h"*</content><author>serena.girardi@studenti.unipd.it</author><question>3</question><insertDate>2014-05-21</insertDate></answer><answer id="6"><content>Beh ... io intendevo il contenuto di TA.h ...</content><author>serena.girardi@studenti.unipd.it</author><question>3</question><insertDate>2014-05-22</insertDate></answer><answer id="7"><content>scusa avevo letto male...&#13;
*#include &lt;stdio.h&gt;&#13;
#include &lt;string.h&gt;&#13;
#include "GPS.h"&#13;
#include "DES.h"&#13;
#include "Posizione.h"&#13;
#include "POSITION.h"&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
#define secondi_settimana 3600*24*7 &#13;
#define file_password "password.bin"&#13;
#define file_position "position.bin"&#13;
&#13;
&#13;
&#13;
&#13;
class TA : public Observer&#13;
{&#13;
private:&#13;
&#13;
//! \var stato&#13;
//! \brief stato del programma&#13;
bool stato;&#13;
&#13;
//! \var positionCount&#13;
//! \brief conto delle posizioni&#13;
unsigned int positionCount;&#13;
&#13;
//! \var direzione&#13;
//! \brief direzione attuale&#13;
double direzione;&#13;
&#13;
//! \var velocita&#13;
//! \brief velocita' attuale&#13;
double velocita;&#13;
&#13;
//! \var positions&#13;
//! \brief vettore delle posizioni&#13;
Posizione* positions;&#13;
&#13;
//! \var positionFile&#13;
//! \brief riferimento al file di salvataggio&#13;
FILE* positionFile;&#13;
&#13;
&#13;
&#13;
&#13;
/*!&#13;
\fn checkPassword&#13;
\brief controlla la password&#13;
\param password utente&#13;
*/&#13;
bool checkPassword(char password[])&#13;
{&#13;
BYTE clear[8], coded[8], pswd[8];&#13;
int passwordLen = strlen(password);&#13;
FILE* passwordFile; &#13;
&#13;
// correzione della password&#13;
if (passwordLen&lt;=8)&#13;
{&#13;
for (int i=0; i&lt;passwordLen; i++)&#13;
clear[i] = password[i];&#13;
for (int i=passwordLen; i&lt;8; i++)&#13;
clear[i] = ' ';&#13;
}&#13;
else&#13;
{&#13;
for (int i=0; i&lt;8; i++)&#13;
clear[i] = password[i];&#13;
}&#13;
&#13;
// codifica della password&#13;
DES_encrypt(clear, coded, clear);&#13;
&#13;
// apertura file&#13;
passwordFile = fopen(file_password,"rb");&#13;
fread(pswd, 8, 1, passwordFile);&#13;
fclose(passwordFile);&#13;
&#13;
// controllo della password&#13;
for (int i=0; i&lt;8; i++)&#13;
if (coded[i] != pswd[i])&#13;
return false;&#13;
return true;&#13;
}&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
/*!&#13;
\fn loadFromFile&#13;
\brief carica le posizioni da file&#13;
\return numero di posizioni caricate, -1 in caso di errore&#13;
*/&#13;
int loadFromFile(const char filename[])&#13;
{&#13;
POSITION pos;&#13;
&#13;
positionFile = fopen(filename, "rb");&#13;
if (positionFile != NULL)&#13;
{&#13;
positionCount = 0;&#13;
while (!feof(positionFile))&#13;
{&#13;
if (fread(&amp;pos,sizeof(POSITION),1,positionFile) == 1)&#13;
{&#13;
Data data(pos.giorno, pos.mese, pos.anno);&#13;
Tempo time(pos.ora, pos.min, pos.sec);&#13;
Latitudine lat(pos.glat, pos.plat, pos.slat, pos.olat);&#13;
Longitudine lon(pos.glon, pos.plon, pos.slon, pos.olon);&#13;
Posizione position(data, time, lat, lon);&#13;
positions[positionCount] = position;&#13;
positionCount++;&#13;
};&#13;
}&#13;
}&#13;
else&#13;
return-1;&#13;
fclose(positionFile);&#13;
return positionCount;&#13;
}&#13;
&#13;
public:&#13;
/*!&#13;
&#13;
\fn distanzaTotale&#13;
&#13;
\brief calcola la distanza totale&#13;
&#13;
\return distanza totale&#13;
&#13;
*/&#13;
double distanzaTotale(void)&#13;
{&#13;
double distanza;&#13;
&#13;
for (unsigned int i=1; i&lt;positionCount; i++)&#13;
distanza += positions[i].distanza(positions[i-1]);&#13;
&#13;
return distanza/1000.0;&#13;
}&#13;
&#13;
&#13;
&#13;
&#13;
/*!&#13;
\fn TA&#13;
\brief costruttore&#13;
*/&#13;
&#13;
TA(void)&#13;
{&#13;
stato = false;&#13;
positionCount = 0;&#13;
direzione = 0.0;&#13;
velocita = 0.0;&#13;
positions = new Posizione[secondi_settimana];&#13;
if (loadFromFile(file_position) &gt;= 0)&#13;
stato = true;&#13;
}&#13;
/*!&#13;
\fn ATC&#13;
\brief distruttore&#13;
*/&#13;
&#13;
~TA(void)&#13;
{&#13;
delete positions;&#13;
}&#13;
&#13;
/*!&#13;
\fn isViaggio&#13;
\brief controllo stato del viaggio&#13;
*/&#13;
bool isViaggio(void)&#13;
{&#13;
return stato;&#13;
}&#13;
&#13;
/*!&#13;
\fn settaViaggio&#13;
\brief inizio del viaggio e memorizzazione della password&#13;
\param password password utente&#13;
*/&#13;
void settaViaggio(char password[])&#13;
{&#13;
BYTE clear[8], coded[8];&#13;
int passwordLen = strlen(password);&#13;
FILE *passwordFile; &#13;
&#13;
if (stato) // viaggio in corso&#13;
return;&#13;
&#13;
// elaborazione della password (aggiustamento della lunghezza se e' minore o maggiore di 8 caratteri)&#13;
if (passwordLen&lt;=8)&#13;
{&#13;
for (int i=0; i&lt;passwordLen; i++)&#13;
clear[i] = password[i];&#13;
for (int i=passwordLen; i&lt;8; i++)&#13;
clear[i] = ' ';&#13;
}&#13;
else&#13;
{&#13;
for (int i=0; i&lt;8; i++)&#13;
clear[i] = password[i];&#13;
}&#13;
&#13;
// codifica password&#13;
DES_encrypt(clear, coded, clear);&#13;
&#13;
// scrittura password codificata su file&#13;
passwordFile = fopen(file_password,"wb");&#13;
fwrite(coded, 8, 1, passwordFile);&#13;
fclose(passwordFile);&#13;
&#13;
// rimozione file delle posizioni&#13;
remove(file_position);&#13;
positionCount = 0;&#13;
stato = true;&#13;
}&#13;
&#13;
/*!&#13;
\fn concludiViaggio&#13;
\brief fine del viaggio&#13;
\param password&#13;
*/&#13;
&#13;
void concludiViaggio(char password[])&#13;
{&#13;
if (stato == false)&#13;
return;&#13;
if (checkPassword(password))&#13;
{&#13;
remove(file_position);&#13;
remove(file_password);&#13;
positionCount = 0;&#13;
stato = false;&#13;
}&#13;
}&#13;
&#13;
&#13;
&#13;
/*!&#13;
\fn posizioneAttuale&#13;
\brief richiesta posizione attuale&#13;
\retval speed velocità (Km/h)&#13;
\retval direction direzione rispetto al Nord (gradi)&#13;
\return posizione attuale&#13;
\note viene restituita l'ultima posizione registrata, o una posizione nulla se il viaggio non è in corso&#13;
*/&#13;
Posizione posizioneAttuale(double* vel, double* dir)&#13;
{&#13;
Latitudine lat;&#13;
Longitudine lon;&#13;
Data date;&#13;
Tempo time;&#13;
Posizione pos(date, time, lat, lon); &#13;
&#13;
*vel = velocita;&#13;
*dir = direzione;&#13;
if (positionCount == 0) // il viaggio non e' in corso&#13;
return pos;&#13;
&#13;
return positions[positionCount-1];&#13;
}&#13;
&#13;
&#13;
&#13;
/*!&#13;
\fn saveFile&#13;
\brief salvataggio su file testuale&#13;
\param filename denominazione/percorso del file&#13;
\param password password utente&#13;
*/&#13;
void saveFile(char filename[], char password[])&#13;
{&#13;
FILE* positionFile;&#13;
char string[128], tmp[8];&#13;
unsigned char crc;&#13;
&#13;
if (stato == false)&#13;
return;&#13;
if (!checkPassword(password))&#13;
return;&#13;
&#13;
positionFile = fopen(filename,"wt");&#13;
for (unsigned int i=0; i&lt;positionCount; i++)&#13;
{&#13;
sprintf(string,"$GPRMC,%02i%02i%02i.000,A,%02i%02.4f,%c,%03i%02.4f,%c,0.00,000.00,%02i%02i%02i*",&#13;
positions[i].getTempo().getOra(), positions[i].getTempo().getMinuti(), positions[i].getTempo().getSecondi(),&#13;
positions[i].getLatitudine().getGradi(),(double)positions[i].getLatitudine().getPrimi()+(double)positions[i].getLatitudine().getSecondi()/60.0,(positions[i].getLatitudine().getOrientamento()&gt;0 ? 'N' : 'S'),&#13;
positions[i].getLongitudine().getGradi(),(double)positions[i].getLongitudine().getPrimi()+(double)positions[i].getLongitudine().getSecondi()/60.0,(positions[i].getLongitudine().getOrientamento()&gt;0 ? 'E' : 'O'),&#13;
positions[i].getData().getGiorno(), positions[i].getData().getMese(), positions[i].getData().getAnno()-2000);&#13;
crc = 0x00;&#13;
for (unsigned int i=1; string[i]!='*'; i++)&#13;
crc ^= string[i];&#13;
sprintf(tmp,"%02X",crc);&#13;
fprintf(positionFile,"%s%s\r\n",string,tmp);&#13;
}&#13;
fclose(positionFile);&#13;
}&#13;
&#13;
/*!&#13;
\fn notify&#13;
\brief funzione ereditata dalla classe GPSobserver ed invocata dalla classe GPS per l'aggiornamento della posizione&#13;
\param position posizione attuale&#13;
\param direction direzione rispetto al Nord (gradi)&#13;
\param speed velocita' (Km/h)&#13;
*/&#13;
void notify(POSITION pos,double direction,double speed)&#13;
{&#13;
positionFile = fopen(file_position, "ab");&#13;
fwrite(&amp;pos, sizeof(pos), 1, positionFile);&#13;
fclose(positionFile);&#13;
&#13;
direzione = direction;&#13;
velocita = speed;&#13;
}&#13;
};*</content><author>giacomo.fornari@studenti.unipd.it</author><question>3</question><insertDate>2014-05-22</insertDate></answer><answer id="8"><content>1) INFINITO: qualuque numero MOOOOLTO grande va bene. A seconda del tipo di numero che usi, e' definito il numero piu' grande esprimibile: int, long, long long, float, double, long double. Tra l'altro, se cerchi un po' con Google, trovi anche il .h che contiene le definizioni di tali valori.&#13;
&#13;
2) fondamentalmente ti serve sapere quali nodi del grafi hai processato e quali devi ancora processare.&#13;
Non esiste una soluzione unica. Immagina una possibile soluzione e descrivila. Poi se ne parla.&#13;
&#13;
Molto dipende da come identificherai i nodi del grafo:&#13;
&#13;
1) mediante un intero?&#13;
2) mediante una stringa?&#13;
3) mediante il puntatore&#13;
4) mediante un numero generato a caso?&#13;
5) qualche altro meccanismo?</content><author>giacomo.fornari@studenti.unipd.it</author><question>4</question><insertDate>2014-05-22</insertDate></answer>
<answer id="9"><content>Innanzitutto ti ringrazio per la risposta.  :) &#13;
&#13;
Tornando all'esercizio:&#13;
1) chiarissimo, il tipo che uso è double.&#13;
&#13;
2) è quello il problema purtroppo. Perdona la mia scarsezza in programmazione ma non saprei proprio come fare.  :| &#13;
&#13;
Per quanto riguarda "Molto dipende da come identificherai i nodi del grafo":&#13;
I nodi del grafo sono stringhe, per la precisione sono 5 nodi:&#13;
v_a, v_b, v_c, v_d, v_e&#13;
&#13;
Per evitare di creare confusione sappi che questo esercizio funziona così: &#13;
-Acquisisco dei dati da un file di testo (fatto)&#13;
-Li inserisco in una struttura dati: grafo (fatto)&#13;
-Calcolo il percorso più breve tra vertice sorgente (inserito da tastiera) e vertice destinazione (idem) in base ad una tipologia di distanza (d1, d2 o d3, sempre inserita da tastiera): da fare.&#13;
&#13;
Questi sono i dati acquisiti da file (per darti un'idea):&#13;
*5&#13;
3&#13;
v_a v_b 8.2 5.3 9.7&#13;
v_a v_c 2.5 1.4 3.2&#13;
v_a v_e 3.6 5.0 2.7&#13;
3&#13;
v_b v_a 1.4 5.2 0.1&#13;
v_b v_c 8.5 11.4 0.2&#13;
v_b v_e 6.9 2.4 2.8&#13;
2&#13;
v_c v_d 2.7 6.2 1.1&#13;
v_c v_e 3.8 4.4 3.4&#13;
3&#13;
v_d v_a 18.2 7.3 19.7&#13;
v_d v_c 12.5 1.6 5.4&#13;
v_d v_e 11.6 3.2 12.7&#13;
1&#13;
v_e v_a 12.6 16.2 14.1*</content><author>giacomo.fornari@studenti.unipd.it</author><question>4</question><insertDate>2014-05-24</insertDate></answer><answer id="10"><content>Ora che ci penso, per rappresentare questi due:&#13;
/costruisci un insieme per i vertici già considerati (inizialmente vuoto) .;&#13;
/costruisci una struttura per i vertici da considerare (inizialmente tutti) .;&#13;
&#13;
potrei utilizzare code o pile, giusto?&#13;
Alla fin fine l'algoritmo di Dijkstra prevede inserimenti e rimozioni, mi sembra un buon compromesso, mi sbaglio? :o</content><author>enrico.rotundo@studenti.unipd.it</author><question>4</question><insertDate>2014-05-30</insertDate></answer><answer id="11"><content>Sono ancora bloccato su questo:&#13;
/costruisci un insieme per i vertici già considerati (inizialmente vuoto) .;&#13;
/costruisci una struttura per i vertici da considerare (inizialmente tutti) .;&#13;
&#13;
qualcuno sa dirmi qualcosa di più?</content><author>federico.poli.1@studenti.unipd.it</author><question>4</question><insertDate>2014-05-30</insertDate></answer><answer id="12"><content>Dove sta' il problema?&#13;
&#13;
Qualunque struttura dati che possa contenere una collezione di oggetti va bene.&#13;
&#13;
Quali strutture dati che possono contenere collezioni di oggetti conosci?&#13;
&#13;
Un po' di iniziativa, suvvia! &#13;
&#13;
Non stai sparando ad un innocente!</content><author>giacomo.fornari@studenti.unipd.it</author><question>4</question><insertDate>2014-05-30</insertDate></answer><answer id="13"><content>Per l'insieme dei vertici già considerati (inizialmente vuoto) penso che una coda vada benissimo.&#13;
&#13;
Per la struttura in cui inizialmente ci sono tutti i vertici invece non saprei in quanto nell'algoritmo dice di rimuovere il vertice con distanza_min minima. E' possibile fare ciò in code/pile? Da quello che ho capito sulle dispense, le code usano il principio FIFO e le pile LIFO, ma potrei sbagliarmi.&#13;
&#13;
Poi altra cosa, una volta decisa la struttura in cui devono essere presenti tutti i vertici, devo fare un'altra funzione in cui inserisco tutti i vertici del grafo in questa struttura?  :? &#13;
Troppi dubbi. z_z</content><author>federico.poli.1@studenti.unipd.it</author><question>4</question><insertDate>2014-05-30</insertDate></answer><answer id="14"><content>strtok() ti ritorna un char *, un puntatore alla stringa; per trasformarlo in intero devi utilizzare atoi()</content><author>serena.girardi@studenti.unipd.it</author><question>4</question><insertDate>2014-05-30</insertDate></answer><answer id="15"><content>Ma quindi strtok la devo togliere ed utilizzare solo atoi?</content><author>giacomo.fornari@studenti.unipd.it</author><question>4</question><insertDate>2014-05-30</insertDate></answer><answer id="16"><content>strtok la usi per ottenere la sottostringa e la atoi per convertire la sottostringa ottenuta&#13;
&#13;
P.S. Il ciclo while non ha senso dato che la strtok la usi per ogni campo</content><author>federico.poli.1@studenti.unipd.it</author><question>4</question><insertDate>2014-05-30</insertDate></answer><answer id="17"><content>Ok, funziona. &#13;
Però, quando faccio la stessa operazione per caricare l'intero array di struttura parco:&#13;
void leggi_automobili(char* nomefile, Automobile parco[10], int *n)&#13;
{&#13;
   FILE *f = fopen(nomefile, "r");&#13;
   int i = 0;&#13;
   char buffer[100], *str, *token;&#13;
   if(f == NULL) printf("Errore apertura file");&#13;
   else&#13;
   {&#13;
      fscanf(f, "%d", &amp;*n);&#13;
      if(*n &gt; 10)&#13;
      {&#13;
         printf("Il parco non puo' contenere piu' di dieci automobili.");&#13;
         return;&#13;
      }&#13;
      else&#13;
      {&#13;
         fseek(f, 2, 0);&#13;
         while(!feof(f))&#13;
         {&#13;
            while( i &lt; *n)&#13;
            {&#13;
               str = fgets(buffer, 200, f);&#13;
               token = strtok(str, " ");&#13;
               while(token != NULL)&#13;
               {&#13;
                  //printf("The token is: %s\n", token);&#13;
                  strcpy(parco[i].marca, token);&#13;
                  token = strtok(NULL, " ");&#13;
                  strcpy(parco[i].modello, token);&#13;
                  token = strtok(NULL, " ");&#13;
                  parco[i].prezzo = atoi(token);&#13;
                  token = strtok(NULL, " ");&#13;
               }&#13;
               i++;&#13;
&#13;
            }&#13;
            &#13;
         }&#13;
         for(i = 0; i &lt; *n; i++)&#13;
         {&#13;
            printf("marca: %s\n", parco[i].marca);&#13;
            printf("modello: %s\n", parco[i].modello);&#13;
            printf("prezzo: %d\n", parco[i].prezzo);&#13;
            printf("\n");&#13;
         }&#13;
            &#13;
      }&#13;
   }&#13;
}&#13;
</content><author>federico.poli.1@studenti.unipd.it</author><question>4</question><insertDate>2014-05-30</insertDate></answer><answer id="18"><content>Non mi stampa niente. Sto sbagliando sicuro qualcosa con i cicli  f30</content><author>enrico.rotundo@studenti.unipd.it</author><question>4</question><insertDate>2014-05-30</insertDate></answer><answer id="19"><content>Così non si capisce ... sicuramente la strtok non è usata correttamente ...&#13;
&#13;
Posta il main e il file dei dati ...</content><author>giacomo.fornari@studenti.unipd.it</author><question>4</question><insertDate>2014-05-30</insertDate></answer><answer id="20"><content>Sì, scusa.&#13;
&#13;
*#include "esercizio.h"&#13;
&#13;
int main(int argc, char** argv){&#13;
    char* nomefile = "file1.txt";&#13;
    &#13;
    Automobile parco[10];&#13;
    int n;&#13;
    leggi_automobili(nomefile,parco,&amp;n);    &#13;
    &#13;
}*</content><author>federico.poli.1@studenti.unipd.it</author><question>4</question><insertDate>2014-05-30</insertDate></answer><answer id="21"><content>Quindi ...&#13;
&#13;
La fscanf deve essere così&#13;
*fscanf(f, "%d\n", n);*</content><author>giacomo.fornari@studenti.unipd.it</author><question>4</question><insertDate>2014-05-30</insertDate></answer><answer id="22"><content>la fseek la devi **eliminare** e devi eliminare anche il ciclo con la feof e il while della strtok ... in pratica, dall'else fino alla for.</content><author>federico.poli.1@studenti.unipd.it</author><question>4</question><insertDate>2014-05-30</insertDate></answer><answer id="23"><content>Ok, funziona.&#13;
&#13;
Alla fine la feof era inutile in questo caso perché il while(i &lt; *n) è già sufficiente, infatti esso fa tanti cicli quante sono le macchine da inserire (quindi quante ce ne sono nel file stesso). &#13;
&#13;
La fseek l'hai tolta perché hai messo lo \n nello scanf. &#13;
&#13;
Per quanto riguarda con lo  fscanf(f, "%d\n", &amp;*n); funziona anche così.&#13;
&#13;
Quindi fscanf(f, "%d\n", n); è uguale a fscanf(f, "%d\n", &amp;*n); ? &#13;
&#13;
Grazie&#13;
</content><author>federico.poli.1@studenti.unipd.it</author><question>4</question><insertDate>2014-05-30</insertDate></answer><answer id="24"><content>Il fatto è che gli operatori &amp; e * sono uno l'opposto dell'altro quindi &amp;* non si scrive</content><author>giacomo.fornari@studenti.unipd.it</author><question>4</question><insertDate>2014-05-30</insertDate></answer><answer id="25"><content>Ok, capito. Grazie ancora</content><author>giacomo.fornari@studenti.unipd.it</author><question>4</question><insertDate>2014-05-30</insertDate></answer><answer id="26"><content>**TESTO**&#13;
*b) Infine, implementare la funzione C: Automobile* acquistabili(Automobile* parco, int n, int disponibilita, int *m), che,&#13;
presi in input un array “parco” di Automobile le cui prime n componenti sono significative, ed un intero disponibilità,&#13;
restituisce un nuovo array contenente tutte e sole le automobili contenute in parco, il cui prezzo è minore o uguale di disponibilita, &#13;
ed inserisce nella variabile puntata da m il numero di componenti dell’array resituito.*</content><author>serena.girardi@studenti.unipd.it</author><question>4</question><insertDate>2014-05-30</insertDate></answer><answer id="27"><content>&#13;
Mi stampa:&#13;
&#13;
*m: 5&#13;
marca_disp: fiat&#13;
modello_disp: panda&#13;
prezzo_disp: 9000&#13;
&#13;
marca_disp: lancia&#13;
modello_disp: y&#13;
prezzo_disp: 12500&#13;
&#13;
marca_disp: &#13;
modello_disp: &#13;
prezzo_disp: 0&#13;
&#13;
marca_disp: fiat&#13;
modello_disp: punto&#13;
prezzo_disp: 11000&#13;
&#13;
marca_disp: &#13;
modello_disp: &#13;
prezzo_disp: 0&#13;
&#13;
&#13;
Perché alcuni sono vuoti?</content><author>giacomo.fornari@studenti.unipd.it</author><question>4</question><insertDate>2014-05-30</insertDate></answer><answer id="28"><content>Mancano due funzioni ...&#13;
&#13;
Comunque, questa&#13;
&#13;
if(parco[i].prezzo &lt; disponibilita)&#13;
&#13;
deve essere&#13;
&#13;
if(parco[i].prezzo &lt;= disponibilita)&#13;
&#13;
e nel ciclo for, al solito, l'indice i aumenta sempre, anche quando la if non è soddisfatta. Ma **NON** deve essere così perché deve aumentare **SOLO** se la if viene eseguita.&#13;
&#13;
Visto che fai sempre gli stessi errori sui cicli, penso che tu non li abbia compreso veramente ...</content><author>federico.poli.1@studenti.unipd.it</author><question>4</question><insertDate>2014-05-30</insertDate></answer><answer id="29"><content>togli tutti quei punti e virgola dopo le graffe!</content><author>giacomo.fornari@studenti.unipd.it</author><question>1</question><insertDate>2014-05-30</insertDate></answer><answer id="30"><content>Se s è la stringa puoi scrivere&#13;
&#13;
int x = atoi(s.c_str());</content><author>enrico.rotundo@studenti.unipd.it</author><question>5</question><insertDate>2014-05-30</insertDate></answer><answer id="31"><content>Provato. Funziona, grazie mille :)</content><author>giacomo.fornari@studenti.unipd.it</author><question>5</question><insertDate>2014-05-30</insertDate></answer><answer id="32"><content>Non funziona "per magia" ... se avessi letto bene la documentazione della classe&#13;
&#13;
string&#13;
&#13;
del C++, avresti risolto da solo ...</content><author>federico.poli.1@studenti.unipd.it</author><question>5</question><insertDate>2014-05-30</insertDate></answer><answer id="33"><content>Sopra ho scritto che ho provato diversi modi, questo significa che ho cercato nelle librerie del c++, ma purtroppo non ho trovato quello che serviva nel mio specifico caso. Chiedo scusa per la domanda troppo banale. La prossima volta cercherò meglio.</content><author>giacomo.fornari@studenti.unipd.it</author><question>5</question><insertDate>2014-05-30</insertDate></answer><answer id="34"><content>Forse mi sbaglio io, ma per inserire un elemento in coda secondo me dovresti:&#13;
- scorrere tutta la lista finchè trovi next = NULL&#13;
- allocare un nuovo nodo e settargli il valore dell'elemento e next = NULL&#13;
- porre next = nuovo elemento &#13;
Inoltre, la funzione insincoda() avrebbe bisogno di ricevere un puntatore a tipolista solo per gestire il caso di lista vuota, cioè puntatore al primo elemento NULL...</content><author>federico.poli.1@studenti.unipd.it</author><question>6</question><insertDate>2014-05-30</insertDate></answer><answer id="35"><content>Grazie per la risposta!</content><author>federico.poli.1@studenti.unipd.it</author><question>6</question><insertDate>2014-05-30</insertDate></answer><answer id="36"><content>Anche questo lo fa -.-&#13;
void insincoda (tipolista *plis, tipoelem el)</content><author>federico.poli.1@studenti.unipd.it</author><question>6</question><insertDate>2014-05-30</insertDate></answer><answer id="37"><content>Ciao,&#13;
l'errore era nella stampalista. La condizione corretta è&#13;
*while(aux != NULL) stampa*&#13;
Altrimenti ti fermavi sempre al penultimo elemento.&#13;
&#13;
Comunque, se ti va di darci un'occhiata, ho fatto qualche correzione al codice che ne migliora la leggibilità e forse anche un po' la logica...&#13;
&#13;
</content><author>serena.girardi@studenti.unipd.it</author><question>6</question><insertDate>2014-05-30</insertDate></answer><answer id="38"><content>Tu sei un maledetto genio!!! Correggero il codice con il tuo! Grazie!</content><author>enrico.rotundo@studenti.unipd.it</author><question>6</question><insertDate>2014-05-30</insertDate></answer><answer id="39"><content>Prego! Per altri dubbi siamo qui.&#13;
&#13;
f28</content><author>federico.poli.1@studenti.unipd.it</author><question>6</question><insertDate>2014-05-30</insertDate></answer><answer id="40"><content>Altro piccolo dubbio. Nella funzione mia insincoda alla fine viene fatto *plis=pgen-&gt; next. È necessaria questa istruzione? A me pare che il puntatore sempre li rimane (forse è inutile). Grazie</content><author>federico.poli.1@studenti.unipd.it</author><question>6</question><insertDate>2014-05-30</insertDate></answer><answer id="41"><content>Così a occhio non saprei, però la funzione per l'inserimento in coda come l'avevi scritta tu non mi convinceva... Ad esempio perché fai *pgen-&gt;next=*plis;*</content><author>giacomo.fornari@studenti.unipd.it</author><question>6</question><insertDate>2014-05-30</insertDate></answer><answer id="42"><content>Questo sembra più un inserimento in testa...&#13;
&#13;
Diciamo che l'algoritmo generico per l'inserimento in coda è quello che ho seguito nel codice che ti ho postato:&#13;
&#13;
- creo un nuovo nodo al quale assegno il dato che viene fornito come parametro della funzione e metto a NULL il suo campo next&#13;
- se la lista è vuota (controllo che tu non facevi) allora ritorno direttamente il nodo, dato che questo sarà il primo, unico e ultimo elemento di tale lista&#13;
- se invece la lista non è vuota la scorro fino all'ultimo elemento e poi "incollo" il nodo che ho generato all'inizio</content><author>federico.poli.1@studenti.unipd.it</author><question>6</question><insertDate>2014-05-30</insertDate></answer><answer id="43"><content>Cosa fa la funzione controllo?&#13;
&#13;
E come funziona se neanche dovrebbe compilare?</content><author>giacomo.fornari@studenti.unipd.it</author><question>8</question><insertDate>2014-05-30</insertDate></answer><answer id="44"><content>Aspetta posto il codice completo. La parte del minimo l'ho provata a parte e funziona.</content><author>serena.girardi@studenti.unipd.it</author><question>8</question><insertDate>2014-05-30</insertDate></answer><answer id="45"><content>Beh ... la cosa è un po' più complessa ...&#13;
&#13;
La funzione deve essere ricorsiva e deve restituire il puntatore all'elemento minimo dell'array&#13;
&#13;
Non è come avevi detto all'inizio ...</content><author>serena.girardi@studenti.unipd.it</author><question>8</question><insertDate>2014-05-30</insertDate></answer><answer id="46"><content>La funzione non è ricorsiva ma lo è "controllo", la funzione ausiliaria che è chiamata al suo interno. Se leggi le ultime righe del testo c'è scritto:&#13;
&#13;
Nell’implementazione di tale funzione non è consentito l’uso di cicli, né nella funzione stessa né in eventuali funzioni ausiliare che essa dovesse usare.&#13;
&#13;
L'importante è che non tocchi il main. A me serve solo sapere come ritornare il puntatore a quel valore</content><author>serena.girardi@studenti.unipd.it</author><question>8</question><insertDate>2014-05-30</insertDate></answer><answer id="47"><content>L'esercizio dice che la funzione RICORSIVA deve essere questa&#13;
&#13;
float* minimo(const float* array, int size)&#13;
&#13;
con gli ARGOMENTI indicati e NON che deve essere una funzione ausiliaria. Sei fuori strada.</content><author>enrico.rotundo@studenti.unipd.it</author><question>8</question><insertDate>2014-05-30</insertDate></answer><answer id="48"><content>No, mi spiace ma questa volta sbagli tu. C'è scritto chiaramente che si posso utilizzare funzioni ausiliarie. Minimo è la funzione che dovrebbe essere ricorsiva ma che non è, e controllo è quella ausiliaria. Anche il prof ha detto che va bene in questo modo. A me serve sapere come tornare il puntatore a quella componente, grazie </content><author>enrico.rotundo@studenti.unipd.it</author><question>8</question><insertDate>2014-05-30</insertDate></answer><answer id="49"><content>Mi dispiace ma non è come dici tu. L'esercizio è chiaro. La funzione ricorsiva è quella indicate e le funzioni ausiliarie sono EVENTUALI, quindi possono anche non esserci. Se il tuo professore ti ha detto diversamente, cambia professore.&#13;
&#13;
Già che ci sei, dai al tuo professore la soluzione, che è questa (senza alcuna funzione ausiliare e con la funzione ricorsiva implementata come richiesto)</content><author>enrico.rotundo@studenti.unipd.it</author><question>8</question><insertDate>2014-05-30</insertDate></answer><answer id="50"><content>Mah.. Sarà. Comunque, sareste così gentili da spiegarmelo? Non conosco qualche sintassi. Grazie</content><author>enrico.rotundo@studenti.unipd.it</author><question>8</question><insertDate>2014-05-30</insertDate></answer><answer id="51"><content>Cosa non conosci?</content><author>federico.poli.1@studenti.unipd.it</author><question>8</question><insertDate>2014-05-30</insertDate></answer><answer id="52"><content>Il primo if e perché (float *)array tra parentesi?</content><author>serena.girardi@studenti.unipd.it</author><question>8</question><insertDate>2014-05-30</insertDate></answer><answer id="53"><content>Il primo if e perché (float *)array tra parentesi?</content><author>federico.poli.1@studenti.unipd.it</author><question>8</question><insertDate>2014-05-30</insertDate></answer><answer id="54"><content>Parli di questo&#13;
&#13;
*if(--size==0)*&#13;
&#13;
?</content><author>enrico.rotundo@studenti.unipd.it</author><question>8</question><insertDate>2014-05-30</insertDate></answer><answer id="55"><content>Esatto</content><author>giacomo.fornari@studenti.unipd.it</author><question>8</question><insertDate>2014-05-30</insertDate></answer><answer id="56"><content>Non c'è molto da capire ...&#13;
&#13;
E' equivalente a queste due righe&#13;
&#13;
*--size;&#13;
if(size==0)*&#13;
&#13;
Così le comprendi meglio?&#13;
</content><author>federico.poli.1@studenti.unipd.it</author><question>8</question><insertDate>2014-05-30</insertDate></answer><answer id="57"><content>oppure, al posto di&#13;
--size&#13;
hai&#13;
&#13;
size -= 1&#13;
o equivalente&#13;
size = size - 1</content><author>enrico.rotundo@studenti.unipd.it</author><question>8</question><insertDate>2014-05-30</insertDate></answer><answer id="58"><content>Ok grazie. Una curiosità: c'è differenza tra --size e size-- ?&#13;
</content><author>serena.girardi@studenti.unipd.it</author><question>8</question><insertDate>2014-05-30</insertDate></answer><answer id="59"><content>Prova!</content><author>federico.poli.1@studenti.unipd.it</author><question>8</question><insertDate>2014-05-30</insertDate></answer><answer id="60"><content>Chiedi al professore, al libro, a google ... &#13;
&#13;
... preincremento ... postincremento ...</content><author>serena.girardi@studenti.unipd.it</author><question>8</question><insertDate>2014-05-30</insertDate></answer><answer id="61"><content>Sìsì, ho provato. Il codice funzione, grazie!&#13;
&#13;
Però ho delle difficoltà su alcuni passaggi, anzi diciamo tutti.&#13;
&#13;
if(--size==0)&#13;
return (float *)array;&#13;
&#13;
1) Se size è la dimensione dell'array perché dovrebbe decrementare?&#13;
&#13;
min_c = minimo(array, size); &#13;
&#13;
2) Arrivati a questo punto c'è la ricorsione. Ma la funzione minimo riparte da capo oppure min_c si prende il valore della funzione e continua con l'istruzione successiva?&#13;
&#13;
if(*min_c &lt; array[size])&#13;
return min_c;&#13;
&#13;
return (float *)&amp;array[size];&#13;
&#13;
3) Questre tre righe cosa fanno? *min_c cos'è? Size viene utilizzato come indice?&#13;
&#13;
Questo codice è fuori dalla mia portata, non riesco a capirlo. Non ci sarebbe un modo più semplice? Grazie ancora</content><author>giacomo.fornari@studenti.unipd.it</author><question>8</question><insertDate>2014-05-30</insertDate></answer><answer id="62"><content>Sìsì, ho provato. Il codice funzione, grazie!&#13;
&#13;
Però ho delle difficoltà su alcuni passaggi, anzi diciamo tutti.&#13;
&#13;
if(--size==0)&#13;
return (float *)array;&#13;
&#13;
1) Se size è la dimensione dell'array perché dovrebbe decrementare?&#13;
&#13;
min_c = minimo(array, size); &#13;
&#13;
2) Arrivati a questo punto c'è la ricorsione. Ma la funzione minimo riparte da capo oppure min_c si prende il valore della funzione e continua con l'istruzione successiva?&#13;
&#13;
if(*min_c &lt; array[size])&#13;
return min_c;&#13;
&#13;
return (float *)&amp;array[size];&#13;
&#13;
3) Questre tre righe cosa fanno? *min_c cos'è? Size viene utilizzato come indice?&#13;
&#13;
Questo codice è fuori dalla mia portata, non riesco a capirlo. Non ci sarebbe un modo più semplice? Grazie ancora</content><author>serena.girardi@studenti.unipd.it</author><question>8</question><insertDate>2014-05-30</insertDate></answer><answer id="63"><content>No ... la ricorsione non è semplice e qualsiasi altro modo sarebbe di complessità simile.&#13;
&#13;
Che tu non la comprenda non è un problema dato che è un argomento ostico specialmente se non si hanno delle buone basi sul funzionamento a basso livello del sistema (gestione dello stack in particolare).&#13;
&#13;
Quello che mi meraviglia è che il professore (o chi per lui) ti dia questo tipo di esercizi viste le difficoltà di base che hai/avete.</content><author>federico.poli.1@studenti.unipd.it</author><question>8</question><insertDate>2014-05-30</insertDate></answer><answer id="64"><content>Ricorda che la funzione viene chiamata più volte da sé stessa. Ogni volta che viene chiamata il valore di size passato come argomento viene diminuito di 1</content><author>giacomo.fornari@studenti.unipd.it</author><question>8</question><insertDate>2014-05-30</insertDate></answer><answer id="65"><content>La funzione viene chiamata nuovamente e solo quando viene incontrato un return il valore viene passato a min_c&#13;
</content><author>giacomo.fornari@studenti.unipd.it</author><question>8</question><insertDate>2014-05-30</insertDate></answer><answer id="66"><content>*min_c è il valore dell'array puntato da min_c &#13;
Ricorda che min_c è un puntatore</content><author>enrico.rotundo@studenti.unipd.it</author><question>8</question><insertDate>2014-05-30</insertDate></answer><answer id="67"><content>*min_c è il valore dell'array puntato da min_c &#13;
Ricorda che min_c è un puntatore</content><author>federico.poli.1@studenti.unipd.it</author><question>8</question><insertDate>2014-05-30</insertDate></answer><answer id="68"><content>Ah ok! Un'altra cosa, scusa l'ignoranza. Se ogni volta che si arriva a min_c = minimo(array, size); la funzione viene richiamata e quindi "riparte da capo", quand'è che queste istruzioni:&#13;
&#13;
if(*min_c &lt; array[size])&#13;
return min_c;&#13;
&#13;
return (float *)&amp;array[size];&#13;
&#13;
verranno eseguite? &#13;
Comunque, tutti nel mio corso si lamentano di questo fatto. Conosci qualche sito che spieghi bene la ricorsione? Grazie</content><author>serena.girardi@studenti.unipd.it</author><question>8</question><insertDate>2014-05-30</insertDate></answer><answer id="69"><content>Perl &gt; C++ !!</content><author>enrico.rotundo@studenti.unipd.it</author><question>2</question><insertDate>2014-05-30</insertDate></answer><answer id="70"><content>miao</content><author>serena.girardi@studenti.unipd.it</author><question>4</question><insertDate>2014-06-02</insertDate></answer></answers>

</db>
